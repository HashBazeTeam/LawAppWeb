{"version":3,"file":"static/js/561.90c5d80a.chunk.js","mappings":"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","sources":["models/types.js","views/chat/QuestionPool.js"],"sourcesContent":["export const QuestionStatus = {\n    yetToBePicked: \"Yet to be picked\",\n    ongoing: \"Ongoing\",\n    answered: \"Answered\",\n    timeUP: \"Time up\",\n    assistance: \"Assistance\",\n    ended: \"Ended\",\n}","import React, { useEffect, useState } from \"react\";\nimport { useSelector } from \"react-redux\";\nimport { LockClosedIcon } from \"@heroicons/react/solid\";\nimport { toast } from \"react-toastify\";\nimport { useTranslation } from \"react-i18next\";\n\nimport { LoadingIndicator } from \"src/components\";\nimport { deleteEmptyKeys } from \"src/utils/function\";\nimport { questionServices } from \"src/services\";\nimport { QuestionStatus } from \"src/models/types\";\nimport { convertFirestoreTimeStampToDate } from \"src/services/firebase\";\nimport { useDispatch } from \"react-redux\";\nimport { thunks, selectors } from \"src/store\";\n\nconst Table = React.lazy(() => import(\"./components/Table\"));\nconst TableBody = React.lazy(() => import(\"./components/TableBody\"));\n\n/**\n * Chat Pool section to display all the questions with title and date.\n * TODO: Add a cloud function to update stat of question counts\n */\nexport default function QuestionPool(props) {\n  const { t } = useTranslation();\n  const dispatch = useDispatch();\n  const client = props.location.state?.client; // Get the question from the previous page\n  const configs = useSelector(selectors.user.selectConfigs);\n\n  const recordsPerPage = 20; // Records per page\n  const [questionList, setQuestionList] = useState([]);\n  const [maxPages, setMaxPages] = useState(0);\n  const [pageNumber, setPageNumber] = useState(1);\n  const [lastVisibleDoc, setLastVisibleDoc] = useState(null); //  Last visible document in firestore\n  const [loading, setLoading] = useState(false);\n  const [filteredData, setFilteredData] = useState([]);\n  const [filters, setFilters] = useState(filterInitialState);\n  const [filterErrors, setFilterErrors] = useState({});\n  const [filterCountries, setFilterCountries] = useState([]);\n  const [updated, setUpdated] = useState(false);\n\n  /*\n   * Fetch questions\n   */\n  useEffect(() => {\n    let isSubscribed = true;\n    setLoading(true);\n    fetchData().catch((err) => {\n      console.log(err);\n      setLoading(false);\n    });\n    // Cancel any pending request\n    return () => (isSubscribed = false);\n  }, []);\n\n  /*\n   * Fetch questions when client is changed\n   */\n  useEffect(() => {\n    let isSubscribed = true;\n    setLoading(true);\n    fetchData().catch((err) => {\n      console.log(err);\n      setLoading(false);\n    });\n    setLoading(false);\n    // Cancel any pending request\n    return () => (isSubscribed = false);\n  }, [client]);\n\n  // Fetch all the configs and set the redux state\n  useEffect(() => {\n    let isSubscribed = true;\n    const fetchConfigs = async () => {\n      await dispatch(thunks.user.getConfigs());\n    };\n    fetchConfigs().catch((err) => {\n      console.log(err);\n    });\n    return () => {\n      isSubscribed = false;\n    };\n  }, []);\n\n  // Fetch data on page change\n  // move :- next or previous\n  // Firestore doesn't provide a way to get the previous page, so we have to use the lastVisibleDoc\n  const fetchData = async (move) => {\n    setLoading(true);\n    try {\n      let _questions;\n      let _totalCount;\n      let _lastVisible;\n\n      if (client && client.clientID != null) {\n        // Get questions by clientID\n        const { questions, totalCount, lastVisible } =\n          await questionServices.getClientQuestion(\n            client.clientID,\n            recordsPerPage,\n            lastVisibleDoc,\n            move\n          );\n        _questions = questions;\n        _totalCount = totalCount;\n        _lastVisible = lastVisible;\n      } else {\n        const { questions, totalCount, lastVisible } =\n          await questionServices.getAllQuestions(\n            filters.status,\n            recordsPerPage,\n            lastVisibleDoc,\n            move\n          );\n        _questions = questions;\n        _totalCount = totalCount;\n        _lastVisible = lastVisible;\n      }\n\n      setQuestionList(_questions);\n      setFilteredData(_questions);\n      setLastVisibleDoc(_lastVisible);\n      setMaxPages(Math.ceil(_totalCount / recordsPerPage));\n      setLoading(false);\n      setUpdated(!updated);\n    } catch (error) {\n      console.log(error);\n      toast.error(t(\"common_error\"));\n      setLoading(false);\n    }\n    setLoading(false);\n  };\n\n  useEffect(() => {\n    const setTimeOut = async () => {\n      let _questionList = [...questionList];\n      const countrySet = new Set();\n      for (let question of _questionList) {\n        countrySet.add(question.country);\n\n        if (question.status == QuestionStatus.answered) {\n          const answerDateTime = convertFirestoreTimeStampToDate(\n            question.answerDateTime\n          );\n          const currentDate = new Date();\n          const diffTime = currentDate - answerDateTime;\n          const diffHours = diffTime / (1000 * 3600);\n\n          const compareTime = configs?.expiryTime || 24;\n          if (diffHours > compareTime) {\n            question.status = QuestionStatus.timeUP;\n            await questionServices.updateQuestion(question.questionID, {\n              status: QuestionStatus.timeUP,\n            });\n          }\n        }\n      }\n\n      // Set value label pair for country\n      const countryList = Array.from(countrySet);\n      const countryValueLabelPair = countryList.map((country) => {\n        return { value: country, label: country };\n      });\n      setFilterCountries(countryValueLabelPair);\n      setQuestionList(_questionList);\n    };\n\n    setTimeOut();\n  }, [updated]);\n\n  // Reload data\n  const reloadData = async () => {\n    await fetchData();\n  };\n\n  /**\n   * Handle Filter Change\n   */\n  const handleFilterChange = (e) => {\n    const { name, value } = e.target;\n    setFilters({ ...filters, [name]: value });\n  };\n\n  const handleFilterSubmit = (e) => {\n    e.preventDefault();\n    const filterItems = deleteEmptyKeys(filters);\n    if (Object.keys(filterItems).length == 0) {\n      setFilteredData(questionList);\n      return;\n    }\n    const filteredAccounts = questionList.filter((account) => {\n      for (let key in filterItems) {\n        if (filterItems[key] != account[key]) return false;\n      }\n      return true;\n    });\n    setFilteredData(filteredAccounts);\n  };\n\n  const handleClearFilter = () => {\n    setFilters(filterInitialState);\n    setFilteredData(questionList);\n  };\n\n  const tableHeaderCells = [\n    t(\"topic\"),\n    t(\"date\"),\n    t(\"client_name\"),\n    t(\"country\"),\n    t(\"status\"),\n    \"\",\n    \"\",\n  ];\n\n  /**\n   * Pagination related methods.\n   */\n  const handlePageChangePrevious = () => {\n    pageNumber == 1 ? 1 : setPageNumber(pageNumber - 1);\n    fetchData(\"previous\");\n  };\n  const handlePageChangeNext = () => {\n    pageNumber == maxPages ? maxPages : setPageNumber(pageNumber + 1);\n    fetchData(\"next\");\n  };\n\n  return (\n    <>\n      {loading ? (\n        <div className=\"flex justify-center bg-slate-50\">\n          {\" \"}\n          {LoadingIndicator(\"lg\")}{\" \"}\n        </div>\n      ) : (\n        <div className=\"mt-8\">\n          <Table\n            accounts={filteredData}\n            maxPages={maxPages}\n            pageNumber={pageNumber}\n            setPageNumber={setPageNumber}\n            tableHeaderCells={tableHeaderCells}\n            filters={filters}\n            filterErrors={filterErrors}\n            filterOptions={{ filterCountries }}\n            handleFilterChange={handleFilterChange}\n            handleFilterSubmit={handleFilterSubmit}\n            handleClearFilter={handleClearFilter}\n            handlePageChangePrevious={handlePageChangePrevious}\n            handlePageChangeNext={handlePageChangeNext}\n            showFilter={client?.clientID != null ? false : true}\n            reloadData={reloadData}\n          >\n            <TableBody questions={filteredData} />\n          </Table>\n        </div>\n      )}\n    </>\n  );\n}\n\nconst filterInitialState = {\n  status: \"\",\n  country: \"\",\n};\n"],"names":["QuestionStatus","yetToBePicked","ongoing","answered","timeUP","assistance","ended","Table","React","TableBody","QuestionPool","props","t","useTranslation","dispatch","useDispatch","client","location","state","configs","useSelector","selectors","useState","questionList","setQuestionList","maxPages","setMaxPages","pageNumber","setPageNumber","lastVisibleDoc","setLastVisibleDoc","loading","setLoading","filteredData","setFilteredData","filterInitialState","filters","setFilters","filterErrors","filterCountries","setFilterCountries","updated","setUpdated","useEffect","fetchData","catch","err","console","log","fetchConfigs","thunks","move","clientID","questionServices","questions","totalCount","lastVisible","_questions","_totalCount","_lastVisible","status","Math","ceil","toast","setTimeOut","_questionList","countrySet","Set","question","add","country","answerDateTime","convertFirestoreTimeStampToDate","currentDate","Date","diffHours","compareTime","expiryTime","questionID","countryList","Array","from","countryValueLabelPair","map","value","label","reloadData","tableHeaderCells","className","LoadingIndicator","accounts","filterOptions","handleFilterChange","e","target","name","handleFilterSubmit","preventDefault","filterItems","deleteEmptyKeys","Object","keys","length","filteredAccounts","filter","account","key","handleClearFilter","handlePageChangePrevious","handlePageChangeNext","showFilter"],"sourceRoot":""}