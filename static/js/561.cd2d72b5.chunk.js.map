{"version":3,"file":"static/js/561.cd2d72b5.chunk.js","mappings":"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","sources":["models/types.js","views/chat/QuestionPool.js"],"sourcesContent":["export const QuestionStatus = {\n    yetToBePicked: \"Yet to be picked\",\n    ongoing: \"Ongoing\",\n    answered: \"Answered\",\n    timeUP: \"Time up\",\n    assistance: \"Assistance\",\n    ended: \"Ended\",\n}","import React, { useEffect, useState } from \"react\";\nimport { useSelector } from \"react-redux\";\nimport { LockClosedIcon } from \"@heroicons/react/solid\";\nimport { toast } from \"react-toastify\";\nimport { useTranslation } from \"react-i18next\";\n\nimport { LoadingIndicator } from \"src/components\";\nimport { deleteEmptyKeys } from \"src/utils/function\";\nimport { questionServices } from \"src/services\";\nimport { QuestionStatus } from \"src/models/types\";\nimport { convertFirestoreTimeStampToDate } from \"src/services/firebase\";\nimport { useDispatch } from \"react-redux\";\nimport { thunks, selectors } from \"src/store\";\n\nconst Table = React.lazy(() => import(\"./components/Table\"));\nconst TableBody = React.lazy(() => import(\"./components/TableBody\"));\n\n/**\n * Chat Pool section to display all the questions with title and date.\n * TODO: Add a cloud function to update stat of question counts\n */\nexport default function QuestionPool(props) {\n  const { t } = useTranslation();\n  const dispatch = useDispatch();\n  const client = props.location.state?.client; // Get the question from the previous page\n  const configs = useSelector(selectors.user.selectConfigs);\n\n  const recordsPerPage = 20; // Records per page\n  const [questionList, setQuestionList] = useState([]);\n  const [maxPages, setMaxPages] = useState(0);\n  const [pageNumber, setPageNumber] = useState(1);\n  const [lastVisibleDoc, setLastVisibleDoc] = useState(null); //  Last visible document in firestore\n  const [loading, setLoading] = useState(false);\n  const [filteredData, setFilteredData] = useState([]);\n  const [filters, setFilters] = useState(filterInitialState);\n  const [filterErrors, setFilterErrors] = useState({});\n\n  /*\n   * Fetch questions\n   */\n  useEffect(() => {\n    let isSubscribed = true;\n    setLoading(true);\n    fetchData().catch((err) => {\n      console.log(err);\n      setLoading(false);\n    });\n    // Cancel any pending request\n    return () => (isSubscribed = false);\n  }, []);\n\n  /*\n   * Fetch questions when client is changed\n   */\n  useEffect(() => {\n    let isSubscribed = true;\n    setLoading(true);\n    fetchData().catch((err) => {\n      console.log(err);\n      setLoading(false);\n    });\n    setLoading(false);\n    // Cancel any pending request\n    return () => (isSubscribed = false);\n  }, [client]);\n\n  // Fetch all the configs and set the redux state\n  useEffect(() => {\n    let isSubscribed = true;\n    const fetchConfigs = async () => {\n      await dispatch(thunks.user.getConfigs());\n    };\n    fetchConfigs().catch((err) => {\n      console.log(err);\n    });\n    return () => {\n      isSubscribed = false;\n    };\n  }, []);\n\n  // Fetch data on page change\n  // move :- next or previous\n  // Firestore doesn't provide a way to get the previous page, so we have to use the lastVisibleDoc\n  const fetchData = async (move) => {\n    setLoading(true);\n    try {\n      let _questions;\n      let _totalCount;\n      let _lastVisible;\n\n      if (client && client.clientID != null) {\n        // Get questions by clientID\n        const { questions, totalCount, lastVisible } =\n          await questionServices.getClientQuestion(\n            client.clientID,\n            recordsPerPage,\n            lastVisibleDoc,\n            move\n          );\n        _questions = questions;\n        _totalCount = totalCount;\n        _lastVisible = lastVisible;\n      } else {\n        const { questions, totalCount, lastVisible } =\n          await questionServices.getAllQuestions(\n            filters.status,\n            recordsPerPage,\n            lastVisibleDoc,\n            move\n          );\n        _questions = questions;\n        _totalCount = totalCount;\n        _lastVisible = lastVisible;\n      }\n      // Check if the question is in answered status and if the answerDateTime is more than 24 hours then change the\n      // Status in to time up\n      const _questionsT = _questions.map(async (question) => {\n        if (question.status == QuestionStatus.answered) {\n          const answerDateTime = convertFirestoreTimeStampToDate(\n            question.answerDateTime\n          );\n          const currentDate = new Date();\n          const diffTime = currentDate - answerDateTime;\n          const diffHours = diffTime / (1000 * 3600);\n            \n          const compareTime = configs?.expiryTime || 24;\n          if (diffHours > compareTime) {\n            question.status = QuestionStatus.timeUP;\n            await questionServices.updateQuestion(question.questionID, {\n              status: QuestionStatus.timeUP,\n            });\n          }\n        }\n        return question;\n      });\n\n      setQuestionList(_questionsT);\n      setFilteredData(_questions);\n      setLastVisibleDoc(_lastVisible);\n      setMaxPages(Math.ceil(_totalCount / recordsPerPage));\n      setLoading(false);\n    } catch (error) {\n      console.log(error);\n      toast.error(t(\"common_error\"));\n      setLoading(false);\n    }\n    setLoading(false);\n  };\n\n  // Reload data\n  const reloadData = async () => {\n    await fetchData();\n  };\n\n  /**\n   * Handle Filter Change\n   */\n  const handleFilterChange = (e) => {\n    const { name, value } = e.target;\n    setFilters({ ...filters, [name]: value });\n  };\n\n  const handleFilterSubmit = (e) => {\n    e.preventDefault();\n    const filterItems = deleteEmptyKeys(filters);\n    const filteredAccounts = questionList.filter((account) => {\n      for (let key in filterItems) {\n        if (filterItems[key] != account[key]) return false;\n      }\n      return true;\n    });\n    setFilteredData(filteredAccounts);\n  };\n\n  const handleClearFilter = () => {\n    setFilters(filterInitialState);\n    setFilteredData(questionList);\n  };\n\n  const tableHeaderCells = [\n    t(\"topic\"),\n    t(\"date\"),\n    t(\"country\"),\n    t(\"status\"),\n    \"\",\n    \"\",\n  ];\n\n  /**\n   * Pagination related methods.\n   */\n  const handlePageChangePrevious = () => {\n    pageNumber == 1 ? 1 : setPageNumber(pageNumber - 1);\n    fetchData(\"previous\");\n  };\n  const handlePageChangeNext = () => {\n    pageNumber == maxPages ? maxPages : setPageNumber(pageNumber + 1);\n    fetchData(\"next\");\n  };\n\n  return (\n    <>\n      {loading ? (\n        <div className=\"flex justify-center bg-slate-50\">\n          {\" \"}\n          {LoadingIndicator(\"lg\")}{\" \"}\n        </div>\n      ) : (\n        <div className=\"mt-8\">\n          <Table\n            accounts={filteredData}\n            maxPages={maxPages}\n            pageNumber={pageNumber}\n            setPageNumber={setPageNumber}\n            tableHeaderCells={tableHeaderCells}\n            filters={filters}\n            filterErrors={filterErrors}\n            handleFilterChange={handleFilterChange}\n            handleFilterSubmit={handleFilterSubmit}\n            handleClearFilter={handleClearFilter}\n            handlePageChangePrevious={handlePageChangePrevious}\n            handlePageChangeNext={handlePageChangeNext}\n            showFilter={client?.clientID != null ? false : true}\n            reloadData={reloadData}\n          >\n            <TableBody questions={filteredData} />\n          </Table>\n        </div>\n      )}\n    </>\n  );\n}\n\nconst filterInitialState = {\n  status: \"\",\n};\n"],"names":["QuestionStatus","yetToBePicked","ongoing","answered","timeUP","assistance","ended","Table","React","TableBody","QuestionPool","props","t","useTranslation","dispatch","useDispatch","client","location","state","configs","useSelector","selectors","useState","questionList","setQuestionList","maxPages","setMaxPages","pageNumber","setPageNumber","lastVisibleDoc","setLastVisibleDoc","loading","setLoading","filteredData","setFilteredData","filterInitialState","filters","setFilters","filterErrors","useEffect","fetchData","catch","err","console","log","fetchConfigs","thunks","move","clientID","questionServices","questions","totalCount","lastVisible","_questions","_totalCount","_lastVisible","status","_questionsT","map","question","answerDateTime","convertFirestoreTimeStampToDate","currentDate","Date","diffHours","compareTime","expiryTime","questionID","Math","ceil","toast","reloadData","tableHeaderCells","className","LoadingIndicator","accounts","handleFilterChange","e","target","name","value","handleFilterSubmit","preventDefault","filterItems","deleteEmptyKeys","filteredAccounts","filter","account","key","handleClearFilter","handlePageChangePrevious","handlePageChangeNext","showFilter"],"sourceRoot":""}